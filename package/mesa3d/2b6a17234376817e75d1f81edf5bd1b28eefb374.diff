diff --git a/src/freedreno/registers/gen_header.py b/src/freedreno/registers/gen_header.py
index 9657dff014c..480911a280b 100644
--- a/src/freedreno/registers/gen_header.py
+++ b/src/freedreno/registers/gen_header.py
@@ -78,7 +78,7 @@ def ctype(self, var_name):
 			val = "fui(%s)" % var_name
 		elif self.type == "float" and self.high - self.low == 15:
 			type = "float"
-			val = "util_float_to_half(%s)" % var_name
+			val = "_mesa_float_to_half(%s)" % var_name
 		elif self.type in [ "address", "waddress" ]:
 			type = "uint64_t"
 			val = var_name
diff --git a/src/freedreno/rnn/headergen2.c b/src/freedreno/rnn/headergen2.c
index d5a3eb7562e..478dde3e6c2 100644
--- a/src/freedreno/rnn/headergen2.c
+++ b/src/freedreno/rnn/headergen2.c
@@ -201,7 +201,7 @@ static void printtypeinfo (struct rnntypeinfo *ti, struct rnnbitfield *bf,
 			if (width == 32)
 				fprintf(dst, "fui(val)");
 			else if (width == 16)
-				fprintf(dst, "util_float_to_half(val)");
+				fprintf(dst, "_mesa_float_to_half(val)");
 			else
 				assert(!"invalid float size");
 		} else {
diff --git a/src/freedreno/vulkan/tu_clear_blit.c b/src/freedreno/vulkan/tu_clear_blit.c
index a645831ed4c..96e48751105 100644
--- a/src/freedreno/vulkan/tu_clear_blit.c
+++ b/src/freedreno/vulkan/tu_clear_blit.c
@@ -122,7 +122,7 @@ r2d_clear_value(struct tu_cs *cs, VkFormat format, const VkClearValue *val)
             else
                clear_value[i] = tu_pack_float32_for_unorm(linear, 8);
          } else if (ifmt == R2D_FLOAT16) {
-            clear_value[i] = util_float_to_half(val->color.float32[i]);
+            clear_value[i] = _mesa_float_to_half(val->color.float32[i]);
          } else {
             assert(ifmt == R2D_FLOAT32 || ifmt == R2D_INT32 ||
                    ifmt == R2D_INT16 || ifmt == R2D_INT8);
diff --git a/src/gallium/auxiliary/gallivm/lp_bld_const.c b/src/gallium/auxiliary/gallivm/lp_bld_const.c
index 58fdcc94437..63a6599284f 100644
--- a/src/gallium/auxiliary/gallivm/lp_bld_const.c
+++ b/src/gallium/auxiliary/gallivm/lp_bld_const.c
@@ -257,7 +257,7 @@ lp_build_one(struct gallivm_state *gallivm, struct lp_type type)
    elem_type = lp_build_elem_type(gallivm, type);
 
    if(type.floating && type.width == 16)
-      elems[0] = LLVMConstInt(elem_type, util_float_to_half(1.0f), 0);
+      elems[0] = LLVMConstInt(elem_type, _mesa_float_to_half(1.0f), 0);
    else if(type.floating)
       elems[0] = LLVMConstReal(elem_type, 1.0);
    else if(type.fixed)
@@ -304,7 +304,7 @@ lp_build_const_elem(struct gallivm_state *gallivm,
    LLVMValueRef elem;
 
    if(type.floating && type.width == 16) {
-      elem = LLVMConstInt(elem_type, util_float_to_half((float)val), 0);
+      elem = LLVMConstInt(elem_type, _mesa_float_to_half((float)val), 0);
    } else if(type.floating) {
       elem = LLVMConstReal(elem_type, val);
    }
diff --git a/src/gallium/auxiliary/gallivm/lp_bld_conv.c b/src/gallium/auxiliary/gallivm/lp_bld_conv.c
index 2079a2aa4df..9edc1614f38 100644
--- a/src/gallium/auxiliary/gallivm/lp_bld_conv.c
+++ b/src/gallium/auxiliary/gallivm/lp_bld_conv.c
@@ -204,8 +204,8 @@ lp_build_float_to_half(struct gallivm_state *gallivm,
      unsigned i;
 
      LLVMTypeRef func_type = LLVMFunctionType(i16t, &f32t, 1, 0);
-     LLVMValueRef func = lp_build_const_int_pointer(gallivm, func_to_pointer((func_pointer)util_float_to_half));
-     func = LLVMBuildBitCast(builder, func, LLVMPointerType(func_type, 0), "util_float_to_half");
+     LLVMValueRef func = lp_build_const_int_pointer(gallivm, func_to_pointer((func_pointer)_mesa_float_to_half));
+     func = LLVMBuildBitCast(builder, func, LLVMPointerType(func_type, 0), "_mesa_float_to_half");
 
      for (i = 0; i < length; ++i) {
         LLVMValueRef index = LLVMConstInt(i32t, i, 0);
diff --git a/src/gallium/auxiliary/tgsi/tgsi_exec.c b/src/gallium/auxiliary/tgsi/tgsi_exec.c
index ab17c1f9bc2..95c2ec01822 100644
--- a/src/gallium/auxiliary/tgsi/tgsi_exec.c
+++ b/src/gallium/auxiliary/tgsi/tgsi_exec.c
@@ -3325,8 +3325,8 @@ exec_pk2h(struct tgsi_exec_machine *mach,
    fetch_source(mach, &arg[0], &inst->Src[0], TGSI_CHAN_X, TGSI_EXEC_DATA_FLOAT);
    fetch_source(mach, &arg[1], &inst->Src[0], TGSI_CHAN_Y, TGSI_EXEC_DATA_FLOAT);
    for (chan = 0; chan < TGSI_QUAD_SIZE; chan++) {
-      dst.u[chan] = util_float_to_half(arg[0].f[chan]) |
-         (util_float_to_half(arg[1].f[chan]) << 16);
+      dst.u[chan] = _mesa_float_to_half(arg[0].f[chan]) |
+         (_mesa_float_to_half(arg[1].f[chan]) << 16);
    }
    for (chan = 0; chan < TGSI_NUM_CHANNELS; chan++) {
       if (inst->Dst[0].Register.WriteMask & (1 << chan)) {
@@ -3344,8 +3344,8 @@ exec_up2h(struct tgsi_exec_machine *mach,
 
    fetch_source(mach, &arg, &inst->Src[0], TGSI_CHAN_X, TGSI_EXEC_DATA_UINT);
    for (chan = 0; chan < TGSI_QUAD_SIZE; chan++) {
-      dst[0].f[chan] = util_half_to_float(arg.u[chan] & 0xffff);
-      dst[1].f[chan] = util_half_to_float(arg.u[chan] >> 16);
+      dst[0].f[chan] = _mesa_half_to_float(arg.u[chan] & 0xffff);
+      dst[1].f[chan] = _mesa_half_to_float(arg.u[chan] >> 16);
    }
    for (chan = 0; chan < TGSI_NUM_CHANNELS; chan++) {
       if (inst->Dst[0].Register.WriteMask & (1 << chan)) {
diff --git a/src/gallium/auxiliary/translate/translate_generic.c b/src/gallium/auxiliary/translate/translate_generic.c
index d48c8f96655..7af2f93a46a 100644
--- a/src/gallium/auxiliary/translate/translate_generic.c
+++ b/src/gallium/auxiliary/translate/translate_generic.c
@@ -110,7 +110,7 @@ emit_##NAME(const void *attrib, void *ptr)		\
 
 #define TO_64_FLOAT(x)   ((double) x)
 #define TO_32_FLOAT(x)   (x)
-#define TO_16_FLOAT(x)   util_float_to_half(x)
+#define TO_16_FLOAT(x)   _mesa_float_to_half(x)
 
 #define TO_8_USCALED(x)  ((unsigned char) x)
 #define TO_16_USCALED(x) ((unsigned short) x)
diff --git a/src/gallium/auxiliary/util/u_half.h b/src/gallium/auxiliary/util/u_half.h
index 04c59302765..5146897e867 100644
--- a/src/gallium/auxiliary/util/u_half.h
+++ b/src/gallium/auxiliary/util/u_half.h
@@ -44,12 +44,6 @@ extern "C" {
  *  https://gist.github.com/2144712
  */
 
-static inline uint16_t
-util_float_to_half(float f)
-{
-   return _mesa_float_to_half(f);
-}
-
 static inline uint16_t
 util_float_to_half_rtz(float f)
 {
@@ -107,12 +101,6 @@ util_float_to_half_rtz(float f)
    return f16;
 }
 
-static inline float
-util_half_to_float(uint16_t f16)
-{
-   return _mesa_half_to_float(f16);
-}
-
 #ifdef __cplusplus
 }
 #endif
diff --git a/src/gallium/drivers/etnaviv/etnaviv_blend.c b/src/gallium/drivers/etnaviv/etnaviv_blend.c
index 644409a437e..b0479609b9c 100644
--- a/src/gallium/drivers/etnaviv/etnaviv_blend.c
+++ b/src/gallium/drivers/etnaviv/etnaviv_blend.c
@@ -180,11 +180,11 @@ etna_update_blend_color(struct etna_context *ctx)
       VIVS_PE_ALPHA_BLEND_COLOR_A(etna_cfloat_to_uint8(cs->color[3]));
 
    cs->PE_ALPHA_COLOR_EXT0 =
-      VIVS_PE_ALPHA_COLOR_EXT0_B(util_float_to_half(cs->color[rb_swap ? 2 : 0])) |
-      VIVS_PE_ALPHA_COLOR_EXT0_G(util_float_to_half(cs->color[1]));
+      VIVS_PE_ALPHA_COLOR_EXT0_B(_mesa_float_to_half(cs->color[rb_swap ? 2 : 0])) |
+      VIVS_PE_ALPHA_COLOR_EXT0_G(_mesa_float_to_half(cs->color[1]));
    cs->PE_ALPHA_COLOR_EXT1 =
-      VIVS_PE_ALPHA_COLOR_EXT1_R(util_float_to_half(cs->color[rb_swap ? 0 : 2])) |
-      VIVS_PE_ALPHA_COLOR_EXT1_A(util_float_to_half(cs->color[3]));
+      VIVS_PE_ALPHA_COLOR_EXT1_R(_mesa_float_to_half(cs->color[rb_swap ? 0 : 2])) |
+      VIVS_PE_ALPHA_COLOR_EXT1_A(_mesa_float_to_half(cs->color[3]));
 
    return true;
 }
diff --git a/src/gallium/drivers/etnaviv/etnaviv_disasm.c b/src/gallium/drivers/etnaviv/etnaviv_disasm.c
index 56d94e27f05..0be6d9e5a37 100644
--- a/src/gallium/drivers/etnaviv/etnaviv_disasm.c
+++ b/src/gallium/drivers/etnaviv/etnaviv_disasm.c
@@ -379,7 +379,7 @@ print_src(struct etna_inst_src *src, bool sep)
             printf("%d", src->imm_val);
             break;
          case 3: /* 16-bit */
-            printf("%f/%.5X", util_half_to_float(src->imm_val), src->imm_val);
+            printf("%f/%.5X", _mesa_half_to_float(src->imm_val), src->imm_val);
             break;
          }
       } else {
diff --git a/src/gallium/drivers/etnaviv/etnaviv_zsa.c b/src/gallium/drivers/etnaviv/etnaviv_zsa.c
index 7cac316c1da..8e9ced460d6 100644
--- a/src/gallium/drivers/etnaviv/etnaviv_zsa.c
+++ b/src/gallium/drivers/etnaviv/etnaviv_zsa.c
@@ -98,7 +98,7 @@ etna_zsa_state_create(struct pipe_context *pctx,
    uint32_t extra_reference = 0;
 
    if (VIV_FEATURE(screen, chipMinorFeatures1, HALF_FLOAT))
-      extra_reference = util_float_to_half(SATURATE(so->alpha.ref_value));
+      extra_reference = _mesa_float_to_half(SATURATE(so->alpha.ref_value));
 
    cs->PE_STENCIL_CONFIG_EXT =
       VIVS_PE_STENCIL_CONFIG_EXT_EXTRA_ALPHA_REF(extra_reference);
diff --git a/src/gallium/drivers/freedreno/a5xx/fd5_emit.c b/src/gallium/drivers/freedreno/a5xx/fd5_emit.c
index d1e86a50df2..1711fd64f27 100644
--- a/src/gallium/drivers/freedreno/a5xx/fd5_emit.c
+++ b/src/gallium/drivers/freedreno/a5xx/fd5_emit.c
@@ -276,8 +276,8 @@ setup_border_colors(struct fd_texture_stateobj *tex, struct bcolor_entry *entrie
 				float f_s = CLAMP(f, -1, 1);
 
 				e->fp32[c] = fui(f);
-				e->fp16[c] = util_float_to_half(f);
-				e->srgb[c] = util_float_to_half(f_u);
+				e->fp16[c] = _mesa_float_to_half(f);
+				e->srgb[c] = _mesa_float_to_half(f_u);
 				e->ui16[c] = f_u * 0xffff;
 				e->si16[c] = f_s * 0x7fff;
 				e->ui8[c]  = f_u * 0xff;
diff --git a/src/gallium/drivers/freedreno/a6xx/fd6_emit.c b/src/gallium/drivers/freedreno/a6xx/fd6_emit.c
index ff441126e19..d4f73c45a71 100644
--- a/src/gallium/drivers/freedreno/a6xx/fd6_emit.c
+++ b/src/gallium/drivers/freedreno/a6xx/fd6_emit.c
@@ -183,8 +183,8 @@ setup_border_colors(struct fd_texture_stateobj *tex, struct bcolor_entry *entrie
 				float f_s = CLAMP(f, -1, 1);
 
 				e->fp32[c] = fui(f);
-				e->fp16[c] = util_float_to_half(f);
-				e->srgb[c] = util_float_to_half(f_u);
+				e->fp16[c] = _mesa_float_to_half(f);
+				e->srgb[c] = _mesa_float_to_half(f_u);
 				e->ui16[c] = f_u * 0xffff;
 				e->si16[c] = f_s * 0x7fff;
 				e->ui8[c]  = f_u * 0xff;
diff --git a/src/gallium/drivers/freedreno/freedreno_texture.c b/src/gallium/drivers/freedreno/freedreno_texture.c
index 5b0bec17f5d..7ffa5c1ed85 100644
--- a/src/gallium/drivers/freedreno/freedreno_texture.c
+++ b/src/gallium/drivers/freedreno/freedreno_texture.c
@@ -167,7 +167,7 @@ fd_setup_border_colors(struct fd_texture_stateobj *tex, void *ptr,
 				} else {
 					bcolor32[desc->swizzle[j]] = fui(sampler->border_color.f[j]);
 					bcolor[desc->swizzle[j]] =
-						util_float_to_half(sampler->border_color.f[j]);
+						_mesa_float_to_half(sampler->border_color.f[j]);
 				}
 			}
 		}
diff --git a/src/gallium/drivers/lima/ir/pp/codegen.c b/src/gallium/drivers/lima/ir/pp/codegen.c
index 55d3489c51c..8b689cbdf41 100644
--- a/src/gallium/drivers/lima/ir/pp/codegen.c
+++ b/src/gallium/drivers/lima/ir/pp/codegen.c
@@ -568,7 +568,7 @@ static void ppir_codegen_encode_store_temp(ppir_node *node, void *code)
 static void ppir_codegen_encode_const(ppir_const *constant, uint16_t *code)
 {
    for (int i = 0; i < constant->num; i++)
-      code[i] = util_float_to_half(constant->value[i].f);
+      code[i] = _mesa_float_to_half(constant->value[i].f);
 }
 
 static void ppir_codegen_encode_discard(ppir_node *node, void *code)
diff --git a/src/gallium/drivers/lima/ir/pp/disasm.c b/src/gallium/drivers/lima/ir/pp/disasm.c
index a45ab85538b..3ea500b9512 100644
--- a/src/gallium/drivers/lima/ir/pp/disasm.c
+++ b/src/gallium/drivers/lima/ir/pp/disasm.c
@@ -174,7 +174,7 @@ print_const(unsigned const_num, uint16_t *val)
 {
    printf("const%u", const_num);
    for (unsigned i = 0; i < 4; i++)
-      printf(" %f", util_half_to_float(val[i]));
+      printf(" %f", _mesa_half_to_float(val[i]));
 }
 
 static void
diff --git a/src/gallium/drivers/lima/lima_draw.c b/src/gallium/drivers/lima/lima_draw.c
index 8737e5efaf5..672108400a7 100644
--- a/src/gallium/drivers/lima/lima_draw.c
+++ b/src/gallium/drivers/lima/lima_draw.c
@@ -898,7 +898,7 @@ lima_update_pp_uniform(struct lima_context *ctx)
       lima_ctx_buff_alloc(ctx, lima_ctx_buff_pp_uniform_array, 4);
 
    for (int i = 0; i < const_buff_size; i++)
-       fp16_const_buff[i] = util_float_to_half(const_buff[i]);
+       fp16_const_buff[i] = _mesa_float_to_half(const_buff[i]);
 
    *array = lima_ctx_buff_va(ctx, lima_ctx_buff_pp_uniform);
 
diff --git a/src/gallium/drivers/nouveau/nv30/nv30_state_validate.c b/src/gallium/drivers/nouveau/nv30/nv30_state_validate.c
index c67004bdf51..9fbf9b37cee 100644
--- a/src/gallium/drivers/nouveau/nv30/nv30_state_validate.c
+++ b/src/gallium/drivers/nouveau/nv30/nv30_state_validate.c
@@ -182,11 +182,11 @@ nv30_validate_blend_colour(struct nv30_context *nv30)
       case PIPE_FORMAT_R16G16B16A16_FLOAT:
       case PIPE_FORMAT_R32G32B32A32_FLOAT:
          BEGIN_NV04(push, NV30_3D(BLEND_COLOR), 1);
-         PUSH_DATA (push, (util_float_to_half(rgba[0]) <<  0) |
-                          (util_float_to_half(rgba[1]) << 16));
+         PUSH_DATA (push, (_mesa_float_to_half(rgba[0]) <<  0) |
+                          (_mesa_float_to_half(rgba[1]) << 16));
          BEGIN_NV04(push, SUBC_3D(0x037c), 1);
-         PUSH_DATA (push, (util_float_to_half(rgba[2]) <<  0) |
-                          (util_float_to_half(rgba[3]) << 16));
+         PUSH_DATA (push, (_mesa_float_to_half(rgba[2]) <<  0) |
+                          (_mesa_float_to_half(rgba[3]) << 16));
          break;
       default:
          break;
diff --git a/src/gallium/drivers/r300/r300_state.c b/src/gallium/drivers/r300/r300_state.c
index 2d8e5b1832a..8d3db508a33 100644
--- a/src/gallium/drivers/r300/r300_state.c
+++ b/src/gallium/drivers/r300/r300_state.c
@@ -620,10 +620,10 @@ static void r300_set_blend_color(struct pipe_context* pipe,
         switch (cb ? cb->format : 0) {
         case PIPE_FORMAT_R16G16B16A16_FLOAT:
         case PIPE_FORMAT_R16G16B16X16_FLOAT:
-            OUT_CB(util_float_to_half(c.color[2]) |
-                   (util_float_to_half(c.color[3]) << 16));
-            OUT_CB(util_float_to_half(c.color[0]) |
-                   (util_float_to_half(c.color[1]) << 16));
+            OUT_CB(_mesa_float_to_half(c.color[2]) |
+                   (_mesa_float_to_half(c.color[3]) << 16));
+            OUT_CB(_mesa_float_to_half(c.color[0]) |
+                   (_mesa_float_to_half(c.color[1]) << 16));
             break;
 
         default:
@@ -753,7 +753,7 @@ static void* r300_create_dsa_state(struct pipe_context* pipe,
             R300_FG_ALPHA_FUNC_ENABLE;
 
         dsa->alpha_function |= float_to_ubyte(state->alpha.ref_value);
-        alpha_value_fp16 = util_float_to_half(state->alpha.ref_value);
+        alpha_value_fp16 = _mesa_float_to_half(state->alpha.ref_value);
     }
 
     BEGIN_CB(&dsa->cb_begin, 8);
diff --git a/src/gallium/drivers/v3d/v3dx_emit.c b/src/gallium/drivers/v3d/v3dx_emit.c
index 7a1d04efeb5..a8db6b85c6e 100644
--- a/src/gallium/drivers/v3d/v3dx_emit.c
+++ b/src/gallium/drivers/v3d/v3dx_emit.c
@@ -101,11 +101,11 @@ swizzled_border_color(const struct v3d_device_info *devinfo,
 
         switch (swiz) {
         case PIPE_SWIZZLE_0:
-                return util_float_to_half(0.0);
+                return _mesa_float_to_half(0.0);
         case PIPE_SWIZZLE_1:
-                return util_float_to_half(1.0);
+                return _mesa_float_to_half(1.0);
         default:
-                return util_float_to_half(sampler->border_color.f[swiz]);
+                return _mesa_float_to_half(sampler->border_color.f[swiz]);
         }
 }
 
diff --git a/src/gallium/drivers/v3d/v3dx_state.c b/src/gallium/drivers/v3d/v3dx_state.c
index ee41b9fa75e..6b078d55a35 100644
--- a/src/gallium/drivers/v3d/v3dx_state.c
+++ b/src/gallium/drivers/v3d/v3dx_state.c
@@ -52,7 +52,7 @@ v3d_set_blend_color(struct pipe_context *pctx,
         v3d->blend_color.f = *blend_color;
         for (int i = 0; i < 4; i++) {
                 v3d->blend_color.hf[i] =
-                        util_float_to_half(blend_color->color[i]);
+                        _mesa_float_to_half(blend_color->color[i]);
         }
         v3d->dirty |= VC5_DIRTY_BLEND_COLOR;
 }
@@ -691,13 +691,13 @@ v3d_upload_sampler_state_variant(void *map,
                                 sampler.border_color_word_3 = border.ui[3];
                         } else {
                                 sampler.border_color_word_0 =
-                                        util_float_to_half(border.f[0]);
+                                        _mesa_float_to_half(border.f[0]);
                                 sampler.border_color_word_1 =
-                                        util_float_to_half(border.f[1]);
+                                        _mesa_float_to_half(border.f[1]);
                                 sampler.border_color_word_2 =
-                                        util_float_to_half(border.f[2]);
+                                        _mesa_float_to_half(border.f[2]);
                                 sampler.border_color_word_3 =
-                                        util_float_to_half(border.f[3]);
+                                        _mesa_float_to_half(border.f[3]);
                         }
                 }
         }
diff --git a/src/gallium/frontends/nine/vertexshader9.h b/src/gallium/frontends/nine/vertexshader9.h
index cbbd34979c9..0211decf80e 100644
--- a/src/gallium/frontends/nine/vertexshader9.h
+++ b/src/gallium/frontends/nine/vertexshader9.h
@@ -112,8 +112,8 @@ NineVertexShader9_UpdateKey( struct NineVertexShader9 *vs,
      * Use compressed float16 values for the pointsize min/max in the key.
      * Shaders do not usually output psize.*/
     if (vs->point_size) {
-        key |= ((uint64_t)util_float_to_half(asfloat(context->rs[D3DRS_POINTSIZE_MIN]))) << 32;
-        key |= ((uint64_t)util_float_to_half(asfloat(context->rs[D3DRS_POINTSIZE_MAX]))) << 48;
+        key |= ((uint64_t)_mesa_float_to_half(asfloat(context->rs[D3DRS_POINTSIZE_MIN]))) << 32;
+        key |= ((uint64_t)_mesa_float_to_half(asfloat(context->rs[D3DRS_POINTSIZE_MAX]))) << 48;
     }
 
     res = vs->last_key != key;
diff --git a/src/gallium/tests/unit/translate_test.c b/src/gallium/tests/unit/translate_test.c
index b07db7f4eb8..a0c23d7a967 100644
--- a/src/gallium/tests/unit/translate_test.c
+++ b/src/gallium/tests/unit/translate_test.c
@@ -164,7 +164,7 @@ int main(int argc, char** argv)
       double_buffer[i] = rand_double();
 
    for (i = 0; i < buffer_size / sizeof(double); ++i)
-      half_buffer[i] = util_float_to_half((float) rand_double());
+      half_buffer[i] = _mesa_float_to_half((float) rand_double());
 
    for (i = 0; i < count; ++i)
       elts[i] = i;
diff --git a/src/gallium/tests/unit/u_half_test.c b/src/gallium/tests/unit/u_half_test.c
index fb4ce6ec9f2..40b5ccbcaaa 100644
--- a/src/gallium/tests/unit/u_half_test.c
+++ b/src/gallium/tests/unit/u_half_test.c
@@ -18,8 +18,8 @@ test(void)
       union fi f;
       uint16_t rh;
 
-      f.f = util_half_to_float(h);
-      rh = util_float_to_half(f.f);
+      f.f = _mesa_half_to_float(h);
+      rh = _mesa_float_to_half(f.f);
 
       if (h != rh && !(util_is_half_nan(h) && util_is_half_nan(rh))) {
          printf("Roundtrip failed: %x -> %x = %f -> %x\n", h, f.ui, f.f, rh);
diff --git a/src/mesa/vbo/vbo_attrib_tmp.h b/src/mesa/vbo/vbo_attrib_tmp.h
index bfc3a311a35..81ef4b6a4c6 100644
--- a/src/mesa/vbo/vbo_attrib_tmp.h
+++ b/src/mesa/vbo/vbo_attrib_tmp.h
@@ -61,28 +61,28 @@ USE OR OTHER DEALINGS IN THE SOFTWARE.
 
 
 /* half */
-#define ATTR1HV( A, V ) ATTRF( A, 1, util_half_to_float((uint16_t)(V)[0]), \
+#define ATTR1HV( A, V ) ATTRF( A, 1, _mesa_half_to_float((uint16_t)(V)[0]), \
                                0, 0, 1 )
-#define ATTR2HV( A, V ) ATTRF( A, 2, util_half_to_float((uint16_t)(V)[0]), \
-                               util_half_to_float((uint16_t)(V)[1]), 0, 1 )
-#define ATTR3HV( A, V ) ATTRF( A, 3, util_half_to_float((uint16_t)(V)[0]), \
-                               util_half_to_float((uint16_t)(V)[1]), \
-                               util_half_to_float((uint16_t)(V)[2]), 1 )
-#define ATTR4HV( A, V ) ATTRF( A, 4, util_half_to_float((uint16_t)(V)[0]), \
-                               util_half_to_float((uint16_t)(V)[1]), \
-                               util_half_to_float((uint16_t)(V)[2]), \
-                               util_half_to_float((uint16_t)(V)[3]) )
-
-#define ATTR1H( A, X )          ATTRF( A, 1, util_half_to_float(X), 0, 0, 1 )
-#define ATTR2H( A, X, Y )       ATTRF( A, 2, util_half_to_float(X), \
-                                       util_half_to_float(Y), 0, 1 )
-#define ATTR3H( A, X, Y, Z )    ATTRF( A, 3, util_half_to_float(X), \
-                                       util_half_to_float(Y), \
-                                       util_half_to_float(Z), 1 )
-#define ATTR4H( A, X, Y, Z, W ) ATTRF( A, 4, util_half_to_float(X), \
-                                       util_half_to_float(Y), \
-                                       util_half_to_float(Z), \
-                                       util_half_to_float(W) )
+#define ATTR2HV( A, V ) ATTRF( A, 2, _mesa_half_to_float((uint16_t)(V)[0]), \
+                               _mesa_half_to_float((uint16_t)(V)[1]), 0, 1 )
+#define ATTR3HV( A, V ) ATTRF( A, 3, _mesa_half_to_float((uint16_t)(V)[0]), \
+                               _mesa_half_to_float((uint16_t)(V)[1]), \
+                               _mesa_half_to_float((uint16_t)(V)[2]), 1 )
+#define ATTR4HV( A, V ) ATTRF( A, 4, _mesa_half_to_float((uint16_t)(V)[0]), \
+                               _mesa_half_to_float((uint16_t)(V)[1]), \
+                               _mesa_half_to_float((uint16_t)(V)[2]), \
+                               _mesa_half_to_float((uint16_t)(V)[3]) )
+
+#define ATTR1H( A, X )          ATTRF( A, 1, _mesa_half_to_float(X), 0, 0, 1 )
+#define ATTR2H( A, X, Y )       ATTRF( A, 2, _mesa_half_to_float(X), \
+                                       _mesa_half_to_float(Y), 0, 1 )
+#define ATTR3H( A, X, Y, Z )    ATTRF( A, 3, _mesa_half_to_float(X), \
+                                       _mesa_half_to_float(Y), \
+                                       _mesa_half_to_float(Z), 1 )
+#define ATTR4H( A, X, Y, Z, W ) ATTRF( A, 4, _mesa_half_to_float(X), \
+                                       _mesa_half_to_float(Y), \
+                                       _mesa_half_to_float(Z), \
+                                       _mesa_half_to_float(W) )
 
 
 /* int */
diff --git a/src/util/format/u_format_pack.py b/src/util/format/u_format_pack.py
index a9a77923095..4da64dfc0c7 100644
--- a/src/util/format/u_format_pack.py
+++ b/src/util/format/u_format_pack.py
@@ -360,7 +360,7 @@ def conversion_expr(src_channel,
 
     # Promote half to float
     if src_type == FLOAT and src_size == 16:
-        value = 'util_half_to_float(%s)' % value
+        value = '_mesa_half_to_float(%s)' % value
         src_size = 32
 
     # Special case for float <-> ubytes for more accurate results
