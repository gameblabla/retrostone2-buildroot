diff --git a/src/gallium/auxiliary/indices/u_primconvert.c b/src/gallium/auxiliary/indices/u_primconvert.c
index 18a9e5133f6..41d43031360 100644
--- a/src/gallium/auxiliary/indices/u_primconvert.c
+++ b/src/gallium/auxiliary/indices/u_primconvert.c
@@ -108,6 +108,7 @@ util_primconvert_draw_vbo(struct primconvert_context *pc,
    unsigned ib_offset;
 
    util_draw_init_info(&new_info);
+   new_info.index_bounds_valid = info->index_bounds_valid;
    new_info.min_index = info->min_index;
    new_info.max_index = info->max_index;
    new_info.index_bias = info->index_bias;
diff --git a/src/gallium/auxiliary/util/u_draw.h b/src/gallium/auxiliary/util/u_draw.h
index ac1605228a3..af2cf5aef44 100644
--- a/src/gallium/auxiliary/util/u_draw.h
+++ b/src/gallium/auxiliary/util/u_draw.h
@@ -104,6 +104,7 @@ util_draw_arrays_instanced(struct pipe_context *pipe,
    info.count = count;
    info.start_instance = start_instance;
    info.instance_count = instance_count;
+   info.index_bounds_valid = true;
    info.min_index = start;
    info.max_index = start + count - 1;
 
diff --git a/src/gallium/auxiliary/util/u_vbuf.c b/src/gallium/auxiliary/util/u_vbuf.c
index d7be7ef82ed..c10041e2124 100644
--- a/src/gallium/auxiliary/util/u_vbuf.c
+++ b/src/gallium/auxiliary/util/u_vbuf.c
@@ -1373,6 +1373,7 @@ void u_vbuf_draw_vbo(struct u_vbuf *mgr, const struct pipe_draw_info *info,
           * These values determine the user buffer bounds to upload.
           */
          new_info.index_bias = index_bias0;
+         new_info.index_bounds_valid = true;
          new_info.min_index = ~0u;
          new_info.max_index = 0;
          new_info.start_instance = ~0u;
@@ -1469,7 +1470,7 @@ void u_vbuf_draw_vbo(struct u_vbuf *mgr, const struct pipe_draw_info *info,
       if (u_vbuf_need_minmax_index(mgr)) {
          unsigned max_index;
 
-         if (new_info.max_index != ~0u) {
+         if (new_info.index_bounds_valid) {
             min_index = new_info.min_index;
             max_index = new_info.max_index;
          } else {
diff --git a/src/gallium/drivers/lima/lima_draw.c b/src/gallium/drivers/lima/lima_draw.c
index f489b6e3e54..a6165f397b4 100644
--- a/src/gallium/drivers/lima/lima_draw.c
+++ b/src/gallium/drivers/lima/lima_draw.c
@@ -1061,7 +1061,7 @@ lima_draw_vbo_indexed(struct pipe_context *pctx,
 
    /* Mali Utgard GPU always need min/max index info for index draw,
     * compute it if upper layer does not do for us */
-   if (info->max_index != ~0u) {
+   if (info->index_bounds_valid) {
       ctx->min_index = info->min_index;
       ctx->max_index = info->max_index;
       needs_indices = false;
diff --git a/src/gallium/drivers/panfrost/pan_cmdstream.c b/src/gallium/drivers/panfrost/pan_cmdstream.c
index 48c34c47927..1a7a1cb6c91 100644
--- a/src/gallium/drivers/panfrost/pan_cmdstream.c
+++ b/src/gallium/drivers/panfrost/pan_cmdstream.c
@@ -69,7 +69,7 @@ panfrost_get_index_buffer_bounded(struct panfrost_context *ctx,
         bool needs_indices = true;
         mali_ptr out = 0;
 
-        if (info->max_index != ~0u) {
+        if (info->index_bounds_valid) {
                 *min_index = info->min_index;
                 *max_index = info->max_index;
                 needs_indices = false;
diff --git a/src/gallium/frontends/lavapipe/lvp_execute.c b/src/gallium/frontends/lavapipe/lvp_execute.c
index 6ee7b0be016..7513312c668 100644
--- a/src/gallium/frontends/lavapipe/lvp_execute.c
+++ b/src/gallium/frontends/lavapipe/lvp_execute.c
@@ -1840,6 +1840,7 @@ static void handle_update_buffer(struct lvp_cmd_buffer_entry *cmd,
 static void handle_draw_indexed(struct lvp_cmd_buffer_entry *cmd,
                                 struct rendering_state *state)
 {
+   state->info.index_bounds_valid = false;
    state->info.min_index = 0;
    state->info.max_index = ~0;
    state->info.index_size = state->index_size;
@@ -1864,6 +1865,7 @@ static void handle_draw_indirect(struct lvp_cmd_buffer_entry *cmd,
                                  struct rendering_state *state, bool indexed)
 {
    if (indexed) {
+      state->info.index_bounds_valid = false;
       state->info.index_size = state->index_size;
       state->info.index.resource = state->index_buffer;
       state->info.max_index = ~0;
diff --git a/src/gallium/frontends/nine/nine_state.c b/src/gallium/frontends/nine/nine_state.c
index c93bca047a6..c6c44bbba7b 100644
--- a/src/gallium/frontends/nine/nine_state.c
+++ b/src/gallium/frontends/nine/nine_state.c
@@ -2358,6 +2358,7 @@ CSMT_ITEM_NO_WAIT(nine_context_draw_indexed_primitive,
     info.index_size = context->index_size;
     info.start = context->index_offset / context->index_size + StartIndex;
     info.index_bias = BaseVertexIndex;
+    info.index_bounds_valid = true;
     /* These don't include index bias: */
     info.min_index = MinVertexIndex;
     info.max_index = MinVertexIndex + NumVertices - 1;
@@ -2409,6 +2410,7 @@ CSMT_ITEM_NO_WAIT(nine_context_draw_indexed_primitive_from_vtxbuf_idxbuf,
     info.index_size = index_size;
     info.start = index_offset / info.index_size;
     info.index_bias = 0;
+    info.index_bounds_valid = true;
     info.min_index = MinVertexIndex;
     info.max_index = MinVertexIndex + NumVertices - 1;
     info.has_user_indices = ibuf == NULL;
diff --git a/src/gallium/include/pipe/p_state.h b/src/gallium/include/pipe/p_state.h
index 4ab4cb12e1a..3bf5832d448 100644
--- a/src/gallium/include/pipe/p_state.h
+++ b/src/gallium/include/pipe/p_state.h
@@ -761,8 +761,10 @@ struct pipe_draw_info
    ubyte vertices_per_patch; /**< the number of vertices per patch */
    ubyte index_size;  /**< if 0, the draw is not indexed. */
    bool primitive_restart:1;
-   bool has_user_indices:1; /**< if true, use index.user_buffer */
-   char _pad:6;             /**< padding for memcmp */
+   bool has_user_indices:1;   /**< if true, use index.user_buffer */
+   bool index_bounds_valid:1; /**< whether min_index and max_index are valid;
+                                   they're always invalid if index_size == 0 */
+   char _pad:5;               /**< padding for memcmp */
 
    unsigned start_instance; /**< first instance id */
    unsigned instance_count; /**< number of instances */
diff --git a/src/mesa/state_tracker/st_draw.c b/src/mesa/state_tracker/st_draw.c
index 4d90042bdea..b80052ce186 100644
--- a/src/mesa/state_tracker/st_draw.c
+++ b/src/mesa/state_tracker/st_draw.c
@@ -188,9 +188,11 @@ st_draw_vbo(struct gl_context *ctx,
       if (!index_bounds_valid && st->draw_needs_minmax_index) {
          vbo_get_minmax_indices(ctx, prims, ib, &min_index, &max_index,
                                 nr_prims);
+         index_bounds_valid = true;
       }
 
       info.index_size = 1 << ib->index_size_shift;
+      info.index_bounds_valid = index_bounds_valid;
       info.min_index = min_index;
       info.max_index = max_index;
 
diff --git a/src/mesa/state_tracker/st_draw_feedback.c b/src/mesa/state_tracker/st_draw_feedback.c
index 62804151f63..4441e683049 100644
--- a/src/mesa/state_tracker/st_draw_feedback.c
+++ b/src/mesa/state_tracker/st_draw_feedback.c
@@ -130,8 +130,10 @@ st_feedback_draw_vbo(struct gl_context *ctx,
 
    st_validate_state(st, ST_PIPELINE_RENDER);
 
-   if (ib && !index_bounds_valid)
+   if (ib && !index_bounds_valid) {
       vbo_get_minmax_indices(ctx, prims, ib, &min_index, &max_index, nr_prims);
+      index_bounds_valid = true;
+   }
 
    /* must get these after state validation! */
    struct st_common_variant_key key;
@@ -201,6 +203,7 @@ st_feedback_draw_vbo(struct gl_context *ctx,
       }
 
       info.index_size = index_size;
+      info.index_bounds_valid = index_bounds_valid;
       info.min_index = min_index;
       info.max_index = max_index;
       info.has_user_indices = true;
